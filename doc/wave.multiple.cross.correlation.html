<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>R: Wavelet routine for multiple cross-correlation</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="R.css">
</head><body>

<table width="100%" summary="page for wave.multiple.cross.correlation"><tr><td>wave.multiple.cross.correlation</td><td align="right">R Documentation</td></tr></table>

<h2>
Wavelet routine for multiple cross-correlation
</h2>

<h3>Description</h3>

<p>
Produces an estimate of the multiscale multiple cross-correlation
(as defined below).
</p>


<h3>Usage</h3>

<pre>
 wave.multiple.cross.correlation(xx, lag.max = NULL, ymaxr = NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>xx</code></td>
<td>

A list of <i>n</i> (multiscaled) time series, usually the outcomes of dwt or modwt, <EM>i.e.</EM>
xx &lt;- list(v1.modwt.bw, v2.modwt.bw, v3.modwt.bw)</td></tr>
<tr valign="top"><td><code>lag.max</code></td>
<td>

maximum lag. If not set, it defaults to half the square root of the length of the
original series.
</td></tr>
<tr valign="top"><td><code>ymaxr</code></td>
<td>

index number of the variable whose correlation is calculated against a linear combination
of the rest, otherwise at each wavelet level wmc chooses
the one maximizing the multiple correlation.
</td></tr>
</table>


<h3>Details</h3>

<p>
The routine calculates one single set of wavelet multiple cross-correlations out of <i>n</i> variables
that can be plotted as one single set of graphs (one per wavelet level), as an
alternative to trying to make sense out of <i>n(n-1)/2 x J</i> sets of wavelet cross-correlations. The code is
based on the calculation, at each wavelet scale, of the square root of the coefficient of
determination in a linear combination of variables that includes a lagged variable for which such coefficient of determination
is a maximum. 



</p>


<h3>Value</h3>

<p>
List of two elements:<br>
<EM>xy.mulcor:</EM> matrix with as many rows as levels in the wavelet transform object.
The columns provide the point estimates for the wavelet multiple cross-correlations at different lags.<br>
<EM>YmaxR:</EM> numeric vector giving, at each wavelet level, the index number of the variable
whose correlation is calculated against a linear combination of the rest. By default,
<EM>wmcc</EM> chooses at each wavelet level the variable maximizing the multiple correlation.
</p>


<h3>Note</h3>

<p>
Needs <EM>waveslim</EM> package to calculate <EM>dwt</EM> or <EM>modwt</EM> coefficients as inputs to the routine (also for data in the example).
</p>


<h3>Author(s)</h3>

<p>
Javier Fernández-Macho, Dpt. of Econometrics and Statistics,
&amp; Instituto de Economía Pública,
University of the Basque Country,
Agirre Lehendakari etorb. 83, E48015 BILBAO, Spain. (email: javier.fernandezmacho@ehu.es).
</p>


<h3>References</h3>

<p>
Fernández-Macho, Javier (2011) The wavelet multiple correlation, (mimeo).
</p>


<h3>Examples</h3>

<pre>
## Based on data from Figure 7.9 in Gencay, Selcuk and Whitcher (2001)
## plus one random series.

library(wavemulcor)
data(exchange)
returns &lt;- diff(log(exchange))
returns &lt;- ts(returns, start=1970, freq=12)
wf &lt;- "d4"
J &lt;- 6
lmax &lt;- 36
n &lt;- dim(returns)[1]

demusd.modwt &lt;- modwt(returns[,"DEM.USD"], wf, J)
demusd.modwt.bw &lt;- brick.wall(demusd.modwt, wf)
jpyusd.modwt &lt;- modwt(returns[,"JPY.USD"], wf, J)
jpyusd.modwt.bw &lt;- brick.wall(jpyusd.modwt, wf)
rand.modwt &lt;- modwt(rnorm(length(returns[,"DEM.USD"])), wf, J)
rand.modwt.bw &lt;- brick.wall(rand.modwt, wf)

##xx &lt;- list(demusd.modwt.bw, jpyusd.modwt.bw)
xx &lt;- list(demusd.modwt.bw, jpyusd.modwt.bw, rand.modwt.bw)

Lst &lt;- wave.multiple.cross.correlation(xx, lmax)
returns.cross.cor &lt;- as.matrix(Lst$xy.mulcor[1:J,])
YmaxR &lt;- Lst$YmaxR

exchange.names &lt;- c("DEM.USD", "JPY.USD", "RAND")
rownames(returns.cross.cor)&lt;-rownames(returns.cross.cor, 
  do.NULL = FALSE, prefix = "Level ")
lags &lt;- length(-lmax:lmax)

lower.ci &lt;- tanh(atanh(returns.cross.cor) - qnorm(0.975) /
sqrt(matrix(trunc(n/2^(1:J)), nrow=J, ncol=lags)- 3))
upper.ci &lt;- tanh(atanh(returns.cross.cor) + qnorm(0.975) /
sqrt(matrix(trunc(n/2^(1:J)), nrow=J, ncol=lags)- 3))

par(mfrow=c(3,2), las=1, pty="m", mar=c(2,3,1,0)+.1, oma=c(1.2,1.2,0,0))
for(i in J:1) {
matplot((1:(2*lmax+1)),returns.cross.cor[i,], type="l", lty=1, ylim=c(-1,1), 
  xaxt="n", xlab="", ylab="", main=rownames(returns.cross.cor)[[i]][1])
if(i&lt;3) {axis(side=1, at=seq(1, 2*lmax+1, by=12), 
  labels=seq(-lmax, lmax, by=12))}
#axis(side=2, at=c(-.2, 0, .5, 1))
lines(lower.ci[i,], lty=1, col=2) ##Add Connected Line Segments to a Plot
lines(upper.ci[i,], lty=1, col=2)
abline(h=0,v=lmax+1)              ##Add Straight horiz and vert Lines to a Plot
text(1,1, labels=exchange.names[YmaxR[i]], adj=0.25, cex=.8)
}
par(las=0)
mtext('Lag (months)', side=1, outer=TRUE, adj=0.5)
mtext('Wavelet Multiple Cross-Correlation', side=2, outer=TRUE, adj=0.5)
</pre>


</body></html>
